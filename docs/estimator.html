<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>adnmtf.estimator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>adnmtf.estimator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging

import numpy as np

from .nmtf_utils import StatusBox, build_clusters, global_sign

logger = logging.getLogger(__name__)


# TODO (pcotte): typing

class Estimator:
    &#34;&#34;&#34;
    Estimator object. Created by `nmtf.nmtf.NMTF.fit_transform`, and updated by `nmtf.nmtf.NMTF.predict` and
    `nmtf.nmtf.NMTF.fit_transform.permutation_test_score`. The same Estimator class is used both by NMF and NTF, the
    difference will be that some attributes will be None in the case of NMF.

    Attributes
    -------
    w: array-like, shape (n_samples, n_components)
        Solution to the non-negative least squares problem.
    h: array-like, shape (n_components, n_features)
        Solution to the non-negative least squares problem.
    q: array-like, shape (n_blocks, n_components)
        Only for NTF. Solution to the non-negative least squares problem.
    volume: scalar, volume occupied by W and H
    wb: array-like, shape (n_samples, n_components)
        A sample is clustered in cluster k if its leverage on component k is higher than on any other
        components. During each run of the bootstrap, samples are re-clustered.
        Each row of WB contains the frequencies of the n_components clusters following the bootstrap.
        Only if n_bootstrap &gt; 0.
    hb: array-like, shape (n_components, n_features)
        A feature is clustered in cluster k if its leverage on component k is higher than on any other
        components. During each run of the bootstrap, features are re-clustered.
        Each row of HB contains the frequencies of the n_components clusters following the bootstrap.
        Only if n_bootstrap &gt; 0.
    b: array-like, shape (n_observations, n_components) or (n_features, n_components)
        Only for NMF and only if active convex variant, H = B.T @ X or W = X @ B
    diff: scalar, objective minimum achieved
    wl: array-like, shape (n_samples, n_components)\n
        Set by `nmtf.estimator.Estimator.predict`. Sample leverage on each component\n
    hl: array-like, shape (n_features, n_components)\n
        Set by `nmtf.estimator.Estimator.predict`. Feature leverage on each component\n
    ql: array-like, shape (n_blocks, n_components)\n
        Set by `nmtf.estimator.Estimator.predict`. Block leverage on each component (NTF only)\n
    wr: vector-like, shape (n_samples)\n
        Set by `nmtf.estimator.Estimator.predict`. Ranked sample indexes (by cluster and leverage or stability)
        Used to produce ordered heatmaps\n
    hr: vector-like, shape (n_features)\n
        Set by `nmtf.estimator.Estimator.predict`. Ranked feature indexes (by cluster and leverage or stability)
        Used to produce ordered heatmaps\n
    wn: vector-like, shape (n_components)\n
        Set by `nmtf.estimator.Estimator.predict`. Sample cluster bounds in ordered heatmap\n
    hn: vector-like, shape (n_components)\n
        Set by `nmtf.estimator.Estimator.predict`. Feature cluster bounds in ordered heatmap\n
    wc: vector-like, shape (n_samples)\n
        Set by `nmtf.estimator.Estimator.predict`. Sample assigned cluster\n
    hc: vector-like, shape (n_features)\n
        Set by `nmtf.estimator.Estimator.predict`. Feature assigned cluster\n
    qc: vector-like, shape (size(blocks))\n
        Set by `nmtf.estimator.Estimator.predict`. Block assigned cluster (NTF only)
    score: float
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The true score without permuting targets.
    pvalue: float
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The p-value, which approximates the probability that
        the score would be obtained by chance.
    cs: array-like, shape(n_components)
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The size of each cluster
    cp: array-like, shape(n_components)
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The pvalue of the most significant group within each
        cluster
    cg: array-like, shape(n_components)
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The index of the most significant group within each
        cluster
    cn: array-like, shape(n_components, n_groups)
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The size of each group within each cluster
    &#34;&#34;&#34;
    def __init__(self, w, h, volume, diff, leverage, verbose, wb=None, hb=None, b=None, q=None):
        self.w = w
        self.h = h
        self.volume = volume
        self.wb = wb
        self.hb = hb
        self.diff = diff
        self.leverage = leverage
        self.verbose = verbose
        self.b = b
        self.q = q
        self.wl = None
        self.hl = None
        self.wr = None
        self.hr = None
        self.wn = None
        self.hn = None
        self.wc = None
        self.hc = None
        self.ql = None
        self.qc = None
        self.score = None
        self.pvalue = None
        self.cs = None
        self.cp = None
        self.cg = None
        self.cn = None
        
        if q is None:
            self.kind = &#34;nmf&#34;
        else:
            self.kind = &#34;ntf&#34;
        
        if b is not None and self.kind == &#34;ntf&#34;:
            raise ValueError(&#34;NTF estimator can not have &#39;b&#39; attribute&#34;)

    def predict(self, blocks=None, cluster_by_stability=False, custom_order=False):
        &#34;&#34;&#34;Derives from factorization result ordered sample and feature indexes for future use in ordered heatmaps

        Parameters
        ----------
        blocks: array-like, shape(n_blocks), default None
            Size of each block (if any) in ordered heatmap.
        cluster_by_stability: boolean, default False
             Use stability instead of leverage to assign samples/features to clusters
        custom_order:  boolean, default False
             if False samples/features with highest leverage or stability appear on top of each cluster
             if True within cluster ordering is modified to suggest a continuum  between adjacent clusters
        &#34;&#34;&#34;
        mt = self.w
        mw = self.h
        if self.kind == &#34;ntf&#34;:
            # X is a 3D tensor, in unfolded form of a 2D array
            # horizontal concatenation of blocks of equal size.
            mb = self.q
            nmf_algo = &#34;ntf&#34;
            n_blocks = mb.shape[0]
            blk_size = mw.shape[0] * np.ones(n_blocks)
        else:
            mb = np.array([])
            nmf_algo = &#34;nmf&#34;
            if blocks is None:
                n_blocks = 1
                blk_size = np.array([mw.shape[0]])
            else:
                n_blocks = blocks.shape[0]
                blk_size = blocks

        if self.wb is not None:
            mt_pct = self.wb
        else:
            mt_pct = None

        if self.hb is not None:
            mw_pct = self.hb
        else:
            mw_pct = None

        if self.leverage == &#34;standard&#34;:
            nmf_calculate_leverage = 1
            nmf_use_robust_leverage = 0
        elif self.leverage == &#34;robust&#34;:
            nmf_calculate_leverage = 1
            nmf_use_robust_leverage = 1
        else:
            nmf_calculate_leverage = 0
            nmf_use_robust_leverage = 0

        if cluster_by_stability is True:
            nmf_robust_cluster_by_stability = 1
        else:
            nmf_robust_cluster_by_stability = 0

        if custom_order is True:
            cell_plot_ordered_clusters = 1
        else:
            cell_plot_ordered_clusters = 0

        add_message = []
        my_status_box = StatusBox(verbose=self.verbose)

        (
            mtn,
            mwn,
            mbn,
            r_ct,
            r_cw,
            n_ct,
            n_cw,
            row_clust,
            col_clust,
            block_clust,
            add_message,
            err_message,
            cancel_pressed,
        ) = build_clusters(
            mt=mt,
            mw=mw,
            mb=mb,
            mt_pct=mt_pct,
            mw_pct=mw_pct,
            n_blocks=n_blocks,
            blk_size=blk_size,
            nmf_calculate_leverage=nmf_calculate_leverage,
            nmf_use_robust_leverage=nmf_use_robust_leverage,
            nmf_algo=nmf_algo,
            nmf_robust_cluster_by_stability=nmf_robust_cluster_by_stability,
            cell_plot_ordered_clusters=cell_plot_ordered_clusters,
            add_message=add_message,
            my_status_box=my_status_box,
        )
        for message in add_message:
            logger.info(message)

        my_status_box.close()
        self.update(
            wl=mtn,
            hl=mwn,
            wr=r_ct,
            hr=r_cw,
            wn=n_ct,
            hn=n_cw,
            wc=row_clust,
            hc=col_clust,
            ql=mbn,
            qc=block_clust
        )

    # TODO (pcotte): this function is not called by any pytest. Make a pytest calling it.
    def permutation_test_score(self, y, n_permutations=100):
        &#34;&#34;&#34;Derives from factorization result ordered sample and feature indexes for future use in ordered heatmaps

        Parameters
        ----------
        y:  array-like, group to be predicted
        n_permutations:  integer, default: 100
        &#34;&#34;&#34;
        mt = self.w
        r_ct = self.wr
        n_ct = self.wn
        row_groups = y
        uniques, index = np.unique([row for row in row_groups], return_index=True)
        list_groups = row_groups[index]
        nb_groups = list_groups.shape[0]
        ngroup = np.zeros(nb_groups)
        for group in range(0, nb_groups):
            ngroup[group] = np.where(row_groups == list_groups[group])[0].shape[0]

        nrun = n_permutations
        my_status_box = StatusBox(verbose=self.verbose)
        cluster_size, pglob, prun, cluster_prob, cluster_group, cluster_ngroup, cancel_pressed = global_sign(
            nrun, nb_groups, mt, r_ct, n_ct, row_groups, list_groups, ngroup, my_status_box
        )

        self.update(
            score=prun,
            pvalue=pglob,
            cs=cluster_size,
            cp=cluster_prob,
            cg=cluster_group,
            cn=cluster_ngroup,
        )

    def update(self, **kwargs):
        &#34;&#34;&#34;Updates this estimator&#39;s attributes according to given keyword arguments. Only attributes already defined
        in the estimator can be updated this way.&#34;&#34;&#34;
        for item in kwargs:
            if not hasattr(self, item):
                raise ValueError(f&#34;Can not update attribute &#39;{item}&#39;&#34;)
            setattr(self, item, kwargs.get(item))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="adnmtf.estimator.Estimator"><code class="flex name class">
<span>class <span class="ident">Estimator</span></span>
<span>(</span><span>w, h, volume, diff, leverage, verbose, wb=None, hb=None, b=None, q=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimator object. Created by <code>nmtf.nmtf.NMTF.fit_transform</code>, and updated by <code>nmtf.nmtf.NMTF.predict</code> and
<code>nmtf.nmtf.NMTF.fit_transform.permutation_test_score</code>. The same Estimator class is used both by NMF and NTF, the
difference will be that some attributes will be None in the case of NMF.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>array-like, shape (n_samples, n_components)</code></dt>
<dd>Solution to the non-negative least squares problem.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>array-like, shape (n_components, n_features)</code></dt>
<dd>Solution to the non-negative least squares problem.</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>array-like, shape (n_blocks, n_components)</code></dt>
<dd>Only for NTF. Solution to the non-negative least squares problem.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>scalar, volume occupied by W and H</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>wb</code></strong> :&ensp;<code>array-like, shape (n_samples, n_components)</code></dt>
<dd>A sample is clustered in cluster k if its leverage on component k is higher than on any other
components. During each run of the bootstrap, samples are re-clustered.
Each row of WB contains the frequencies of the n_components clusters following the bootstrap.
Only if n_bootstrap &gt; 0.</dd>
<dt><strong><code>hb</code></strong> :&ensp;<code>array-like, shape (n_components, n_features)</code></dt>
<dd>A feature is clustered in cluster k if its leverage on component k is higher than on any other
components. During each run of the bootstrap, features are re-clustered.
Each row of HB contains the frequencies of the n_components clusters following the bootstrap.
Only if n_bootstrap &gt; 0.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>array-like, shape (n_observations, n_components)</code> or <code>(n_features, n_components)</code></dt>
<dd>Only for NMF and only if active convex variant, H = B.T @ X or W = X @ B</dd>
<dt><strong><code>diff</code></strong> :&ensp;<code>scalar, objective minimum achieved</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>wl</code></strong> :&ensp;<code>array-like, shape (n_samples, n_components)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.predict</code>. Sample leverage on each component</dd>
<dt><strong><code>hl</code></strong> :&ensp;<code>array-like, shape (n_features, n_components)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.predict</code>. Feature leverage on each component</dd>
<dt><strong><code>ql</code></strong> :&ensp;<code>array-like, shape (n_blocks, n_components)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.predict</code>. Block leverage on each component (NTF only)</dd>
<dt><strong><code>wr</code></strong> :&ensp;<code>vector-like, shape (n_samples)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.predict</code>. Ranked sample indexes (by cluster and leverage or stability)
Used to produce ordered heatmaps</dd>
<dt><strong><code>hr</code></strong> :&ensp;<code>vector-like, shape (n_features)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.predict</code>. Ranked feature indexes (by cluster and leverage or stability)
Used to produce ordered heatmaps</dd>
<dt><strong><code>wn</code></strong> :&ensp;<code>vector-like, shape (n_components)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.predict</code>. Sample cluster bounds in ordered heatmap</dd>
<dt><strong><code>hn</code></strong> :&ensp;<code>vector-like, shape (n_components)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.predict</code>. Feature cluster bounds in ordered heatmap</dd>
<dt><strong><code>wc</code></strong> :&ensp;<code>vector-like, shape (n_samples)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.predict</code>. Sample assigned cluster</dd>
<dt><strong><code>hc</code></strong> :&ensp;<code>vector-like, shape (n_features)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.predict</code>. Feature assigned cluster</dd>
<dt><strong><code>qc</code></strong> :&ensp;<code>vector-like, shape (size(blocks))</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.predict</code>. Block assigned cluster (NTF only)</dd>
<dt><strong><code>score</code></strong> :&ensp;<code>float</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.permutation_test_score</code>. The true score without permuting targets.</dd>
<dt><strong><code>pvalue</code></strong> :&ensp;<code>float</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.permutation_test_score</code>. The p-value, which approximates the probability that
the score would be obtained by chance.</dd>
<dt><strong><code>cs</code></strong> :&ensp;<code>array-like, shape(n_components)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.permutation_test_score</code>. The size of each cluster</dd>
<dt><strong><code>cp</code></strong> :&ensp;<code>array-like, shape(n_components)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.permutation_test_score</code>. The pvalue of the most significant group within each
cluster</dd>
<dt><strong><code>cg</code></strong> :&ensp;<code>array-like, shape(n_components)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.permutation_test_score</code>. The index of the most significant group within each
cluster</dd>
<dt><strong><code>cn</code></strong> :&ensp;<code>array-like, shape(n_components, n_groups)</code></dt>
<dd>Set by <code>nmtf.estimator.Estimator.permutation_test_score</code>. The size of each group within each cluster</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Estimator:
    &#34;&#34;&#34;
    Estimator object. Created by `nmtf.nmtf.NMTF.fit_transform`, and updated by `nmtf.nmtf.NMTF.predict` and
    `nmtf.nmtf.NMTF.fit_transform.permutation_test_score`. The same Estimator class is used both by NMF and NTF, the
    difference will be that some attributes will be None in the case of NMF.

    Attributes
    -------
    w: array-like, shape (n_samples, n_components)
        Solution to the non-negative least squares problem.
    h: array-like, shape (n_components, n_features)
        Solution to the non-negative least squares problem.
    q: array-like, shape (n_blocks, n_components)
        Only for NTF. Solution to the non-negative least squares problem.
    volume: scalar, volume occupied by W and H
    wb: array-like, shape (n_samples, n_components)
        A sample is clustered in cluster k if its leverage on component k is higher than on any other
        components. During each run of the bootstrap, samples are re-clustered.
        Each row of WB contains the frequencies of the n_components clusters following the bootstrap.
        Only if n_bootstrap &gt; 0.
    hb: array-like, shape (n_components, n_features)
        A feature is clustered in cluster k if its leverage on component k is higher than on any other
        components. During each run of the bootstrap, features are re-clustered.
        Each row of HB contains the frequencies of the n_components clusters following the bootstrap.
        Only if n_bootstrap &gt; 0.
    b: array-like, shape (n_observations, n_components) or (n_features, n_components)
        Only for NMF and only if active convex variant, H = B.T @ X or W = X @ B
    diff: scalar, objective minimum achieved
    wl: array-like, shape (n_samples, n_components)\n
        Set by `nmtf.estimator.Estimator.predict`. Sample leverage on each component\n
    hl: array-like, shape (n_features, n_components)\n
        Set by `nmtf.estimator.Estimator.predict`. Feature leverage on each component\n
    ql: array-like, shape (n_blocks, n_components)\n
        Set by `nmtf.estimator.Estimator.predict`. Block leverage on each component (NTF only)\n
    wr: vector-like, shape (n_samples)\n
        Set by `nmtf.estimator.Estimator.predict`. Ranked sample indexes (by cluster and leverage or stability)
        Used to produce ordered heatmaps\n
    hr: vector-like, shape (n_features)\n
        Set by `nmtf.estimator.Estimator.predict`. Ranked feature indexes (by cluster and leverage or stability)
        Used to produce ordered heatmaps\n
    wn: vector-like, shape (n_components)\n
        Set by `nmtf.estimator.Estimator.predict`. Sample cluster bounds in ordered heatmap\n
    hn: vector-like, shape (n_components)\n
        Set by `nmtf.estimator.Estimator.predict`. Feature cluster bounds in ordered heatmap\n
    wc: vector-like, shape (n_samples)\n
        Set by `nmtf.estimator.Estimator.predict`. Sample assigned cluster\n
    hc: vector-like, shape (n_features)\n
        Set by `nmtf.estimator.Estimator.predict`. Feature assigned cluster\n
    qc: vector-like, shape (size(blocks))\n
        Set by `nmtf.estimator.Estimator.predict`. Block assigned cluster (NTF only)
    score: float
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The true score without permuting targets.
    pvalue: float
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The p-value, which approximates the probability that
        the score would be obtained by chance.
    cs: array-like, shape(n_components)
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The size of each cluster
    cp: array-like, shape(n_components)
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The pvalue of the most significant group within each
        cluster
    cg: array-like, shape(n_components)
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The index of the most significant group within each
        cluster
    cn: array-like, shape(n_components, n_groups)
        Set by `nmtf.estimator.Estimator.permutation_test_score`. The size of each group within each cluster
    &#34;&#34;&#34;
    def __init__(self, w, h, volume, diff, leverage, verbose, wb=None, hb=None, b=None, q=None):
        self.w = w
        self.h = h
        self.volume = volume
        self.wb = wb
        self.hb = hb
        self.diff = diff
        self.leverage = leverage
        self.verbose = verbose
        self.b = b
        self.q = q
        self.wl = None
        self.hl = None
        self.wr = None
        self.hr = None
        self.wn = None
        self.hn = None
        self.wc = None
        self.hc = None
        self.ql = None
        self.qc = None
        self.score = None
        self.pvalue = None
        self.cs = None
        self.cp = None
        self.cg = None
        self.cn = None
        
        if q is None:
            self.kind = &#34;nmf&#34;
        else:
            self.kind = &#34;ntf&#34;
        
        if b is not None and self.kind == &#34;ntf&#34;:
            raise ValueError(&#34;NTF estimator can not have &#39;b&#39; attribute&#34;)

    def predict(self, blocks=None, cluster_by_stability=False, custom_order=False):
        &#34;&#34;&#34;Derives from factorization result ordered sample and feature indexes for future use in ordered heatmaps

        Parameters
        ----------
        blocks: array-like, shape(n_blocks), default None
            Size of each block (if any) in ordered heatmap.
        cluster_by_stability: boolean, default False
             Use stability instead of leverage to assign samples/features to clusters
        custom_order:  boolean, default False
             if False samples/features with highest leverage or stability appear on top of each cluster
             if True within cluster ordering is modified to suggest a continuum  between adjacent clusters
        &#34;&#34;&#34;
        mt = self.w
        mw = self.h
        if self.kind == &#34;ntf&#34;:
            # X is a 3D tensor, in unfolded form of a 2D array
            # horizontal concatenation of blocks of equal size.
            mb = self.q
            nmf_algo = &#34;ntf&#34;
            n_blocks = mb.shape[0]
            blk_size = mw.shape[0] * np.ones(n_blocks)
        else:
            mb = np.array([])
            nmf_algo = &#34;nmf&#34;
            if blocks is None:
                n_blocks = 1
                blk_size = np.array([mw.shape[0]])
            else:
                n_blocks = blocks.shape[0]
                blk_size = blocks

        if self.wb is not None:
            mt_pct = self.wb
        else:
            mt_pct = None

        if self.hb is not None:
            mw_pct = self.hb
        else:
            mw_pct = None

        if self.leverage == &#34;standard&#34;:
            nmf_calculate_leverage = 1
            nmf_use_robust_leverage = 0
        elif self.leverage == &#34;robust&#34;:
            nmf_calculate_leverage = 1
            nmf_use_robust_leverage = 1
        else:
            nmf_calculate_leverage = 0
            nmf_use_robust_leverage = 0

        if cluster_by_stability is True:
            nmf_robust_cluster_by_stability = 1
        else:
            nmf_robust_cluster_by_stability = 0

        if custom_order is True:
            cell_plot_ordered_clusters = 1
        else:
            cell_plot_ordered_clusters = 0

        add_message = []
        my_status_box = StatusBox(verbose=self.verbose)

        (
            mtn,
            mwn,
            mbn,
            r_ct,
            r_cw,
            n_ct,
            n_cw,
            row_clust,
            col_clust,
            block_clust,
            add_message,
            err_message,
            cancel_pressed,
        ) = build_clusters(
            mt=mt,
            mw=mw,
            mb=mb,
            mt_pct=mt_pct,
            mw_pct=mw_pct,
            n_blocks=n_blocks,
            blk_size=blk_size,
            nmf_calculate_leverage=nmf_calculate_leverage,
            nmf_use_robust_leverage=nmf_use_robust_leverage,
            nmf_algo=nmf_algo,
            nmf_robust_cluster_by_stability=nmf_robust_cluster_by_stability,
            cell_plot_ordered_clusters=cell_plot_ordered_clusters,
            add_message=add_message,
            my_status_box=my_status_box,
        )
        for message in add_message:
            logger.info(message)

        my_status_box.close()
        self.update(
            wl=mtn,
            hl=mwn,
            wr=r_ct,
            hr=r_cw,
            wn=n_ct,
            hn=n_cw,
            wc=row_clust,
            hc=col_clust,
            ql=mbn,
            qc=block_clust
        )

    # TODO (pcotte): this function is not called by any pytest. Make a pytest calling it.
    def permutation_test_score(self, y, n_permutations=100):
        &#34;&#34;&#34;Derives from factorization result ordered sample and feature indexes for future use in ordered heatmaps

        Parameters
        ----------
        y:  array-like, group to be predicted
        n_permutations:  integer, default: 100
        &#34;&#34;&#34;
        mt = self.w
        r_ct = self.wr
        n_ct = self.wn
        row_groups = y
        uniques, index = np.unique([row for row in row_groups], return_index=True)
        list_groups = row_groups[index]
        nb_groups = list_groups.shape[0]
        ngroup = np.zeros(nb_groups)
        for group in range(0, nb_groups):
            ngroup[group] = np.where(row_groups == list_groups[group])[0].shape[0]

        nrun = n_permutations
        my_status_box = StatusBox(verbose=self.verbose)
        cluster_size, pglob, prun, cluster_prob, cluster_group, cluster_ngroup, cancel_pressed = global_sign(
            nrun, nb_groups, mt, r_ct, n_ct, row_groups, list_groups, ngroup, my_status_box
        )

        self.update(
            score=prun,
            pvalue=pglob,
            cs=cluster_size,
            cp=cluster_prob,
            cg=cluster_group,
            cn=cluster_ngroup,
        )

    def update(self, **kwargs):
        &#34;&#34;&#34;Updates this estimator&#39;s attributes according to given keyword arguments. Only attributes already defined
        in the estimator can be updated this way.&#34;&#34;&#34;
        for item in kwargs:
            if not hasattr(self, item):
                raise ValueError(f&#34;Can not update attribute &#39;{item}&#39;&#34;)
            setattr(self, item, kwargs.get(item))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="adnmtf.estimator.Estimator.permutation_test_score"><code class="name flex">
<span>def <span class="ident">permutation_test_score</span></span>(<span>self, y, n_permutations=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Derives from factorization result ordered sample and feature indexes for future use in ordered heatmaps</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like, group to be predicted</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>n_permutations</code></strong> :&ensp;<code> integer</code>, default<code>: 100</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def permutation_test_score(self, y, n_permutations=100):
    &#34;&#34;&#34;Derives from factorization result ordered sample and feature indexes for future use in ordered heatmaps

    Parameters
    ----------
    y:  array-like, group to be predicted
    n_permutations:  integer, default: 100
    &#34;&#34;&#34;
    mt = self.w
    r_ct = self.wr
    n_ct = self.wn
    row_groups = y
    uniques, index = np.unique([row for row in row_groups], return_index=True)
    list_groups = row_groups[index]
    nb_groups = list_groups.shape[0]
    ngroup = np.zeros(nb_groups)
    for group in range(0, nb_groups):
        ngroup[group] = np.where(row_groups == list_groups[group])[0].shape[0]

    nrun = n_permutations
    my_status_box = StatusBox(verbose=self.verbose)
    cluster_size, pglob, prun, cluster_prob, cluster_group, cluster_ngroup, cancel_pressed = global_sign(
        nrun, nb_groups, mt, r_ct, n_ct, row_groups, list_groups, ngroup, my_status_box
    )

    self.update(
        score=prun,
        pvalue=pglob,
        cs=cluster_size,
        cp=cluster_prob,
        cg=cluster_group,
        cn=cluster_ngroup,
    )</code></pre>
</details>
</dd>
<dt id="adnmtf.estimator.Estimator.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, blocks=None, cluster_by_stability=False, custom_order=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Derives from factorization result ordered sample and feature indexes for future use in ordered heatmaps</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>blocks</code></strong> :&ensp;<code>array-like, shape(n_blocks)</code>, default <code>None</code></dt>
<dd>Size of each block (if any) in ordered heatmap.</dd>
<dt><strong><code>cluster_by_stability</code></strong> :&ensp;<code>boolean</code>, default <code>False</code></dt>
<dd>Use stability instead of leverage to assign samples/features to clusters</dd>
<dt><strong><code>custom_order</code></strong> :&ensp;<code> boolean</code>, default <code>False</code></dt>
<dd>if False samples/features with highest leverage or stability appear on top of each cluster
if True within cluster ordering is modified to suggest a continuum
between adjacent clusters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, blocks=None, cluster_by_stability=False, custom_order=False):
    &#34;&#34;&#34;Derives from factorization result ordered sample and feature indexes for future use in ordered heatmaps

    Parameters
    ----------
    blocks: array-like, shape(n_blocks), default None
        Size of each block (if any) in ordered heatmap.
    cluster_by_stability: boolean, default False
         Use stability instead of leverage to assign samples/features to clusters
    custom_order:  boolean, default False
         if False samples/features with highest leverage or stability appear on top of each cluster
         if True within cluster ordering is modified to suggest a continuum  between adjacent clusters
    &#34;&#34;&#34;
    mt = self.w
    mw = self.h
    if self.kind == &#34;ntf&#34;:
        # X is a 3D tensor, in unfolded form of a 2D array
        # horizontal concatenation of blocks of equal size.
        mb = self.q
        nmf_algo = &#34;ntf&#34;
        n_blocks = mb.shape[0]
        blk_size = mw.shape[0] * np.ones(n_blocks)
    else:
        mb = np.array([])
        nmf_algo = &#34;nmf&#34;
        if blocks is None:
            n_blocks = 1
            blk_size = np.array([mw.shape[0]])
        else:
            n_blocks = blocks.shape[0]
            blk_size = blocks

    if self.wb is not None:
        mt_pct = self.wb
    else:
        mt_pct = None

    if self.hb is not None:
        mw_pct = self.hb
    else:
        mw_pct = None

    if self.leverage == &#34;standard&#34;:
        nmf_calculate_leverage = 1
        nmf_use_robust_leverage = 0
    elif self.leverage == &#34;robust&#34;:
        nmf_calculate_leverage = 1
        nmf_use_robust_leverage = 1
    else:
        nmf_calculate_leverage = 0
        nmf_use_robust_leverage = 0

    if cluster_by_stability is True:
        nmf_robust_cluster_by_stability = 1
    else:
        nmf_robust_cluster_by_stability = 0

    if custom_order is True:
        cell_plot_ordered_clusters = 1
    else:
        cell_plot_ordered_clusters = 0

    add_message = []
    my_status_box = StatusBox(verbose=self.verbose)

    (
        mtn,
        mwn,
        mbn,
        r_ct,
        r_cw,
        n_ct,
        n_cw,
        row_clust,
        col_clust,
        block_clust,
        add_message,
        err_message,
        cancel_pressed,
    ) = build_clusters(
        mt=mt,
        mw=mw,
        mb=mb,
        mt_pct=mt_pct,
        mw_pct=mw_pct,
        n_blocks=n_blocks,
        blk_size=blk_size,
        nmf_calculate_leverage=nmf_calculate_leverage,
        nmf_use_robust_leverage=nmf_use_robust_leverage,
        nmf_algo=nmf_algo,
        nmf_robust_cluster_by_stability=nmf_robust_cluster_by_stability,
        cell_plot_ordered_clusters=cell_plot_ordered_clusters,
        add_message=add_message,
        my_status_box=my_status_box,
    )
    for message in add_message:
        logger.info(message)

    my_status_box.close()
    self.update(
        wl=mtn,
        hl=mwn,
        wr=r_ct,
        hr=r_cw,
        wn=n_ct,
        hn=n_cw,
        wc=row_clust,
        hc=col_clust,
        ql=mbn,
        qc=block_clust
    )</code></pre>
</details>
</dd>
<dt id="adnmtf.estimator.Estimator.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates this estimator's attributes according to given keyword arguments. Only attributes already defined
in the estimator can be updated this way.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;Updates this estimator&#39;s attributes according to given keyword arguments. Only attributes already defined
    in the estimator can be updated this way.&#34;&#34;&#34;
    for item in kwargs:
        if not hasattr(self, item):
            raise ValueError(f&#34;Can not update attribute &#39;{item}&#39;&#34;)
        setattr(self, item, kwargs.get(item))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="adnmtf" href="index.html">adnmtf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="adnmtf.estimator.Estimator" href="#adnmtf.estimator.Estimator">Estimator</a></code></h4>
<ul class="">
<li><code><a title="adnmtf.estimator.Estimator.permutation_test_score" href="#adnmtf.estimator.Estimator.permutation_test_score">permutation_test_score</a></code></li>
<li><code><a title="adnmtf.estimator.Estimator.predict" href="#adnmtf.estimator.Estimator.predict">predict</a></code></li>
<li><code><a title="adnmtf.estimator.Estimator.update" href="#adnmtf.estimator.Estimator.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>